# -*- coding: utf-8 -*-
"""synonymous mapping.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ip7S27zL9Stj-zufS4ClNzrvkd51MTbP

Install dependencies and import requirements
"""

!pip install pandas numpy
!pip install gensim openpyxl

import pandas as pd
import numpy as np
from gensim.models import KeyedVectors
import gensim.downloader as api
from google.colab import files

"""Upload Excel file containing male/female words (The format set here is male/female words stored in a different sheet of a table). In addition, there are separate sheet (gender pairs) containing gender words in pair for model training."""

uploaded = files.upload()

"""embedding model: GloVe"""

model = api.load("glove-wiki-gigaword-100")

# Getting the uploaded Excel file
excel_file = list(uploaded.keys())[0]

# read male/female word list
male_df = pd.read_excel(excel_file, sheet_name='male_word')
female_df = pd.read_excel(excel_file, sheet_name='female_word')
try:
    pairs_df = pd.read_excel(excel_file, sheet_name='gender_pairs')  # read data for training
except:
    pairs_df = pd.DataFrame(columns=['male_word', 'female_word'])

# Cleaning the word list
male_words = male_df.iloc[:, 0].dropna().astype(str).tolist()
female_words = female_df.iloc[:, 0].dropna().astype(str).tolist()

print(f"ğŸ“˜ Count of male words: {len(male_words)}")
print(f"ğŸ“• Count of female words: {len(female_words)}")
print(f"ğŸ” Count of gender words in pair: {len(pairs_df)}")

# Prioritise the use of gender_pairs to build gender_direction
vec_diffs = []
for idx, row in pairs_df.iterrows():
    m, f = row['male_word'], row['female_word']
    if m in model and f in model:
        vec_diffs.append(model[f] - model[m])
    else:
        print(f"âš ï¸ Skip missing word vector pairing: {m} - {f}")

if vec_diffs:
    gender_direction = np.mean(vec_diffs, axis=0)
    print("âœ… Gender direction vectors constructed based on gender_pairs")
else:
    print("âš ï¸ Use fallback: all female-male average")
    male_vecs = [model[w] for w in male_words if w in model]
    female_vecs = [model[w] for w in female_words if w in model]
    gender_direction = np.mean(female_vecs, axis=0) - np.mean(male_vecs, axis=0)

# Gender mapping function
def get_gender_counterpart(word, direction, topn=10):
    if word not in model:
        return None
    new_vec = model[word] + direction
    similar = model.similar_by_vector(new_vec, topn=topn)
    for candidate, _ in similar:
        if candidate.lower() != word.lower():
            return candidate
    return None

# male â†’ female
male_to_female = {}
for w in male_words:
    mapped = get_gender_counterpart(w, gender_direction)
    male_to_female[w] = mapped

# female â†’ male
female_to_male = {}
for w in female_words:
    mapped = get_gender_counterpart(w, -gender_direction)
    female_to_male[w] = mapped

male_df_out = pd.DataFrame.from_dict(male_to_female, orient='index', columns=['female_synonym'])
male_df_out.index.name = 'male_word'
male_df_out.reset_index(inplace=True)

female_df_out = pd.DataFrame.from_dict(female_to_male, orient='index', columns=['male_synonym'])
female_df_out.index.name = 'female_word'
female_df_out.reset_index(inplace=True)

male_df_out.to_csv('male_to_female_mapping.csv', index=False)
female_df_out.to_csv('female_to_male_mapping.csv', index=False)

files.download('male_to_female_mapping.csv')
files.download('female_to_male_mapping.csv')

"""Evaluation with PCA"""

!pip install openpyxl --quiet

import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from google.colab import files

uploaded = files.upload() # upload result of gender_synonym_map

import numpy as np
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity

excel_file = list(uploaded.keys())[0]
df = pd.read_excel(excel_file)

male_words = df['male_word'].dropna().astype(str).tolist()
female_words = df['female_word'].dropna().astype(str).tolist()

labels = []
male_vecs = []
female_vecs = []

for m, f in zip(male_words, female_words):
    if m in model and f in model:
        male_vecs.append(model[m])
        female_vecs.append(model[f])
        labels.append((m, f))
    else:
        print(f"âš ï¸ missing word vector: {m} - {f}")

# Perform PCA downscaling
all_vecs = np.array(male_vecs + female_vecs)
pca = PCA(n_components=2)
proj = pca.fit_transform(all_vecs)

# Showing the explained variance ratio
explained_var = pca.explained_variance_ratio_
print("ğŸ“Š PCA Explained Variance Ratio (PC1, PC2):", explained_var)
print(f"Cumulative proportion of variance explained: {explained_var.sum():.2%}")

plt.figure(figsize=(12, 8))
n = len(labels)

gender_direction = np.mean(np.array(female_vecs) - np.array(male_vecs), axis=0)
delta_vectors = []
cosine_scores = []

for i in range(n):
    delta = female_vecs[i] - male_vecs[i]
    delta_vectors.append(delta)
    score = cosine_similarity([delta], [gender_direction])[0][0]
    cosine_scores.append(score)

# Statistical outliers (cos too different from average)
mean_cos = np.mean(cosine_scores)
std_cos = np.std(cosine_scores)
outlier_indices = [i for i, score in enumerate(cosine_scores) if abs(score - mean_cos) > 2 * std_cos]

print(f"ğŸ“ˆ Average cosine similarity: {mean_cos:.4f}, standard deviation: {std_cos:.4f}")
print(f"ğŸš¨ Counts of outliersï¼ˆ|score - mean| > 2Ïƒï¼‰: {len(outlier_indices)}")

# visualisation
for i in range(n):
    color = 'orange' if i in outlier_indices else 'gray'

    # male, female scatters
    plt.scatter(proj[i, 0], proj[i, 1], color='blue')
    plt.scatter(proj[i+n, 0], proj[i+n, 1], color='red')

    # arrow
    plt.arrow(proj[i, 0], proj[i, 1],
              proj[i+n, 0] - proj[i, 0],
              proj[i+n, 1] - proj[i, 1],
              color=color, alpha=0.5, head_width=0.08, length_includes_head=True)

    # outlier
    if i in outlier_indices:
        plt.text(proj[i, 0], proj[i, 1], labels[i][0], fontsize=9, color='black')
        plt.text(proj[i+n, 0], proj[i+n, 1], labels[i][1], fontsize=9, color='black')

# plt
plt.title('PCA Projection of Gender Word Pairs')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid(True)
plt.show()

# âœ… åˆ—å‡ºå¼‚å¸¸è¯å¯¹å’Œå®ƒä»¬çš„ cosine ç›¸ä¼¼åº¦
print("\nğŸš¨ å¼‚å¸¸è¯å¯¹ï¼ˆåç¦»æ€§åˆ«æ–¹å‘ï¼‰:")
for i in outlier_indices:
    m, f = labels[i]
    score = cosine_scores[i]
    print(f"{m:15} - {f:15} | cosine ç›¸ä¼¼åº¦: {score:.4f}")

excel_file = list(uploaded.keys())[0]
df = pd.read_excel(excel_file)

# âœ… è·å–å•è¯å¯¹
male_words = df['male_word'].dropna().astype(str).tolist()
female_words = df['female_word'].dropna().astype(str).tolist()

# âœ… æå–æœ‰æ•ˆè¯å‘é‡
labels = []
male_vecs = []
female_vecs = []

for m, f in zip(male_words, female_words):
    if m in model and f in model:
        male_vecs.append(model[m])
        female_vecs.append(model[f])
        labels.append((m, f))
    else:
        print(f"âš ï¸ ç¼ºå¤±è¯å‘é‡: {m} - {f}")

# âœ… æ‰§è¡Œ PCA é™ç»´
all_vecs = np.array(male_vecs + female_vecs)
pca = PCA(n_components=2)
proj = pca.fit_transform(all_vecs)

# âœ… å¯è§†åŒ–æ€§åˆ«æ–¹å‘
plt.figure(figsize=(12, 8))
n = len(labels)

for i in range(n):
    # ç»˜åˆ¶ male å’Œ female ç‚¹
    plt.scatter(proj[i, 0], proj[i, 1], color='blue')
    plt.scatter(proj[i+n, 0], proj[i+n, 1], color='red')

    # ç”»ç®­å¤´ male â†’ female
    plt.arrow(proj[i, 0], proj[i, 1],
              proj[i+n, 0] - proj[i, 0],
              proj[i+n, 1] - proj[i, 1],
              color='gray', alpha=0.5, head_width=0.1, length_includes_head=True)

    # æ ‡ç­¾ï¼ˆå¯é€‰æ‹©æ˜¯å¦æ˜¾ç¤ºï¼‰
    plt.text(proj[i, 0], proj[i, 1], labels[i][0], fontsize=9, color='blue')
    plt.text(proj[i+n, 0], proj[i+n, 1], labels[i][1], fontsize=9, color='red')

# âœ… å›¾è¡¨æ ·å¼
plt.title('PCA Projection of Gender Word Pairs')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid(True)
plt.show()

"""å¤šé‡éªŒè¯"""

from google.colab import files
uploaded = files.upload()

# ğŸ“¦ å®‰è£…ä¾èµ–
!pip install pandas openpyxl --quiet # Keep openpyxl here
!pip install numpy==1.19.5 scipy==1.5.4 scikit-learn==0.24.2 --quiet # Specify compatible versions
!pip install gensim umap-learn spacy -U --quiet # Install other packages
!python -m spacy download en_core_web_md --quiet

import pandas as pd
import numpy as np
from gensim.models import KeyedVectors
import gensim.downloader as api
from google.colab import files
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import umap.umap_ as umap
from sklearn.metrics.pairwise import cosine_similarity
import spacy
from google.colab import drive

# âœ… åŠ è½½ spaCy åµŒå…¥æ¨¡å‹
nlp = spacy.load("en_core_web_md")

# âœ… ä¸Šä¼ æ–‡ä»¶
excel_file = list(uploaded.keys())[0]

# âœ… è¯»å–æ–‡ä»¶ï¼ˆåŒ…å« male_word å’Œ female_word ä¸¤åˆ—ï¼‰
df = pd.read_excel(excel_file)

# âœ… æ„é€ è¯å‘é‡åˆ—è¡¨
male_vecs, female_vecs, labels = [], [], []

for idx, row in df.iterrows():
    m, f = str(row['male_word']), str(row['female_word'])
    if m in nlp.vocab and f in nlp.vocab and nlp.vocab[m].has_vector and nlp.vocab[f].has_vector:
        male_vecs.append(nlp.vocab[m].vector)
        female_vecs.append(nlp.vocab[f].vector)
        labels.append((m, f))

print(f"âœ… æˆåŠŸåŠ è½½ {len(labels)} å¯¹è¯å¯¹ç”¨äºè¯„ä¼°")

# âœ… è®¡ç®—æ€§åˆ«æ–¹å‘
gender_direction = np.mean(female_vecs, axis=0) - np.mean(male_vecs, axis=0)

# âœ… è®¡ç®—æ¯å¯¹è¯çš„æ–¹å‘ä¸æ€§åˆ«æ–¹å‘çš„ä¸€è‡´æ€§ï¼ˆcosine similarityï¼‰
projection_scores = []
for i in range(len(labels)):
    g_vec = female_vecs[i] - male_vecs[i]
    score = cosine_similarity([g_vec], [gender_direction])[0][0]
    projection_scores.append(score)

# âœ… ä¿å­˜æŠ•å½±åˆ†æ•°
score_df = pd.DataFrame(labels, columns=['male_word', 'female_word'])
score_df['cosine_with_gender_direction'] = projection_scores
score_df.to_csv("gender_projection_scores.csv", index=False)
files.download("gender_projection_scores.csv")

# âœ… å¯è§†åŒ–åˆ†å¸ƒ
plt.figure(figsize=(8, 5))
plt.hist(projection_scores, bins=20, color='skyblue', edgecolor='black')
plt.axvline(np.mean(projection_scores), color='red', linestyle='--', label='Mean')
plt.title('Cosine Similarity with Gender Direction')
plt.xlabel('Cosine Similarity')
plt.ylabel('Count')
plt.grid(True)
plt.legend()
plt.show()

# âœ… é™ç»´å¯è§†åŒ–å‡½æ•°
def plot_2d_projection(method='pca'):
    vectors = np.array(male_vecs + female_vecs)
    labels_text = [m for m, _ in labels] + [f for _, f in labels]
    colors = ['blue'] * len(male_vecs) + ['red'] * len(female_vecs)

    try:
        if method == 'pca':
            reducer = PCA(n_components=2)
        elif method == 'tsne':
            # è®¾ç½®è‡ªåŠ¨é€‚åº”çš„ perplexityï¼ˆä¸è¶…è¿‡æ ·æœ¬æ•°çš„ 1/3ï¼‰
            perplexity = min(30, (len(vectors) - 1) // 3)
            reducer = TSNE(n_components=2, perplexity=perplexity, random_state=42)
        elif method == 'umap':
            reducer = umap.UMAP(n_components=2, random_state=42)
        else:
            raise ValueError('Unsupported method')

        proj = reducer.fit_transform(vectors)

        # ç»˜å›¾
        plt.figure(figsize=(10, 7))
        for i, (x, y) in enumerate(proj):
            plt.scatter(x, y, color=colors[i])
            plt.text(x, y, labels_text[i], fontsize=8, alpha=0.6)
        plt.title(f'{method.upper()} Projection of Gender Word Pairs')
        plt.grid(True)
        plt.show()

    except Exception as e:
        print(f"âš ï¸ Could not generate {method.upper()} plot: {str(e)}")

# âœ… ä¸‰ç§é™ç»´æ–¹å¼å¯è§†åŒ–
plot_2d_projection('pca')
plot_2d_projection('tsne')
plot_2d_projection('umap')

"""W2Vç‰ˆæœ¬

0. å®‰è£…ä¾èµ–
1. æŒ‚è½½ Google Driveï¼ˆç”¨äºæ¨¡å‹ç¼“å­˜ï¼‰
2. ä¸‹è½½å¹¶è§£å‹ Word2Vec æ¨¡å‹ï¼ˆè‹¥æœ¬åœ°ä¸å­˜åœ¨ï¼‰
3. åŠ è½½ Word2Vec æ¨¡å‹
"""

!pip install pandas numpy
!pip install gensim openpyxl

import pandas as pd
import numpy as np
from gensim.models import KeyedVectors

import pandas as pd
import numpy as np
from gensim.models import KeyedVectors

from google.colab import drive
drive.mount('/content/drive')

# è‡ªå®šä¹‰è·¯å¾„ï¼šæ¨¡å‹å°†ç¼“å­˜åˆ°è¿™ä¸ªä½ç½®
model_drive_path = "/content/drive/MyDrive/GoogleNews-vectors-negative300.bin"

import os

if not os.path.exists(model_drive_path):
    print("æ¨¡å‹ä¸å­˜åœ¨ï¼Œæ­£åœ¨ä¸‹è½½...")
    !wget -P /tmp/ https://s3.amazonaws.com/dl4j-distribution/GoogleNews-vectors-negative300.bin.gz
    !gunzip /tmp/GoogleNews-vectors-negative300.bin.gz
    !cp /tmp/GoogleNews-vectors-negative300.bin $model_drive_path
else:
    print("æ¨¡å‹å·²å­˜åœ¨ï¼Œè·³è¿‡ä¸‹è½½ã€‚")


from gensim.models import KeyedVectors

model = KeyedVectors.load_word2vec_format(model_drive_path, binary=True)
print("æ¨¡å‹åŠ è½½å®Œæˆ")
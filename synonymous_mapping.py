# -*- coding: utf-8 -*-
"""synonymous mapping.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ip7S27zL9Stj-zufS4ClNzrvkd51MTbP

Install dependencies and import requirements
"""

!pip install pandas numpy
!pip install gensim openpyxl

import pandas as pd
import numpy as np
from gensim.models import KeyedVectors
import gensim.downloader as api
from google.colab import files

"""Upload Excel file containing male/female words (The format set here is male/female words stored in a different sheet of a table). In addition, there are separate sheet (gender pairs) containing gender words in pair for model training."""

uploaded = files.upload()

"""embedding model: GloVe"""

model = api.load("glove-wiki-gigaword-100")

# Getting the uploaded Excel file
excel_file = list(uploaded.keys())[0]

# read male/female word list
male_df = pd.read_excel(excel_file, sheet_name='male_word')
female_df = pd.read_excel(excel_file, sheet_name='female_word')
try:
    pairs_df = pd.read_excel(excel_file, sheet_name='gender_pairs')  # read data for training
except:
    pairs_df = pd.DataFrame(columns=['male_word', 'female_word'])

# Cleaning the word list
male_words = male_df.iloc[:, 0].dropna().astype(str).tolist()
female_words = female_df.iloc[:, 0].dropna().astype(str).tolist()

print(f"📘 Count of male words: {len(male_words)}")
print(f"📕 Count of female words: {len(female_words)}")
print(f"🔁 Count of gender words in pair: {len(pairs_df)}")

# Prioritise the use of gender_pairs to build gender_direction
vec_diffs = []
for idx, row in pairs_df.iterrows():
    m, f = row['male_word'], row['female_word']
    if m in model and f in model:
        vec_diffs.append(model[f] - model[m])
    else:
        print(f"⚠️ Skip missing word vector pairing: {m} - {f}")

if vec_diffs:
    gender_direction = np.mean(vec_diffs, axis=0)
    print("✅ Gender direction vectors constructed based on gender_pairs")
else:
    print("⚠️ Use fallback: all female-male average")
    male_vecs = [model[w] for w in male_words if w in model]
    female_vecs = [model[w] for w in female_words if w in model]
    gender_direction = np.mean(female_vecs, axis=0) - np.mean(male_vecs, axis=0)

# Gender mapping function
def get_gender_counterpart(word, direction, topn=10):
    if word not in model:
        return None
    new_vec = model[word] + direction
    similar = model.similar_by_vector(new_vec, topn=topn)
    for candidate, _ in similar:
        if candidate.lower() != word.lower():
            return candidate
    return None

# male → female
male_to_female = {}
for w in male_words:
    mapped = get_gender_counterpart(w, gender_direction)
    male_to_female[w] = mapped

# female → male
female_to_male = {}
for w in female_words:
    mapped = get_gender_counterpart(w, -gender_direction)
    female_to_male[w] = mapped

male_df_out = pd.DataFrame.from_dict(male_to_female, orient='index', columns=['female_synonym'])
male_df_out.index.name = 'male_word'
male_df_out.reset_index(inplace=True)

female_df_out = pd.DataFrame.from_dict(female_to_male, orient='index', columns=['male_synonym'])
female_df_out.index.name = 'female_word'
female_df_out.reset_index(inplace=True)

male_df_out.to_csv('male_to_female_mapping.csv', index=False)
female_df_out.to_csv('female_to_male_mapping.csv', index=False)

files.download('male_to_female_mapping.csv')
files.download('female_to_male_mapping.csv')

"""Evaluation with PCA"""

!pip install openpyxl --quiet

import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from google.colab import files

uploaded = files.upload() # upload result of gender_synonym_map

import numpy as np
import pandas as pd
from sklearn.metrics.pairwise import cosine_similarity

excel_file = list(uploaded.keys())[0]
df = pd.read_excel(excel_file)

male_words = df['male_word'].dropna().astype(str).tolist()
female_words = df['female_word'].dropna().astype(str).tolist()

labels = []
male_vecs = []
female_vecs = []

for m, f in zip(male_words, female_words):
    if m in model and f in model:
        male_vecs.append(model[m])
        female_vecs.append(model[f])
        labels.append((m, f))
    else:
        print(f"⚠️ missing word vector: {m} - {f}")

# Perform PCA downscaling
all_vecs = np.array(male_vecs + female_vecs)
pca = PCA(n_components=2)
proj = pca.fit_transform(all_vecs)

# Showing the explained variance ratio
explained_var = pca.explained_variance_ratio_
print("📊 PCA Explained Variance Ratio (PC1, PC2):", explained_var)
print(f"Cumulative proportion of variance explained: {explained_var.sum():.2%}")

plt.figure(figsize=(12, 8))
n = len(labels)

gender_direction = np.mean(np.array(female_vecs) - np.array(male_vecs), axis=0)
delta_vectors = []
cosine_scores = []

for i in range(n):
    delta = female_vecs[i] - male_vecs[i]
    delta_vectors.append(delta)
    score = cosine_similarity([delta], [gender_direction])[0][0]
    cosine_scores.append(score)

# Statistical outliers (cos too different from average)
mean_cos = np.mean(cosine_scores)
std_cos = np.std(cosine_scores)
outlier_indices = [i for i, score in enumerate(cosine_scores) if abs(score - mean_cos) > 2 * std_cos]

print(f"📈 Average cosine similarity: {mean_cos:.4f}, standard deviation: {std_cos:.4f}")
print(f"🚨 Counts of outliers（|score - mean| > 2σ）: {len(outlier_indices)}")

# visualisation
for i in range(n):
    color = 'orange' if i in outlier_indices else 'gray'

    # male, female scatters
    plt.scatter(proj[i, 0], proj[i, 1], color='blue')
    plt.scatter(proj[i+n, 0], proj[i+n, 1], color='red')

    # arrow
    plt.arrow(proj[i, 0], proj[i, 1],
              proj[i+n, 0] - proj[i, 0],
              proj[i+n, 1] - proj[i, 1],
              color=color, alpha=0.5, head_width=0.08, length_includes_head=True)

    # outlier
    if i in outlier_indices:
        plt.text(proj[i, 0], proj[i, 1], labels[i][0], fontsize=9, color='black')
        plt.text(proj[i+n, 0], proj[i+n, 1], labels[i][1], fontsize=9, color='black')

# plt
plt.title('PCA Projection of Gender Word Pairs')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid(True)
plt.show()

# ✅ 列出异常词对和它们的 cosine 相似度
print("\n🚨 异常词对（偏离性别方向）:")
for i in outlier_indices:
    m, f = labels[i]
    score = cosine_scores[i]
    print(f"{m:15} - {f:15} | cosine 相似度: {score:.4f}")

excel_file = list(uploaded.keys())[0]
df = pd.read_excel(excel_file)

# ✅ 获取单词对
male_words = df['male_word'].dropna().astype(str).tolist()
female_words = df['female_word'].dropna().astype(str).tolist()

# ✅ 提取有效词向量
labels = []
male_vecs = []
female_vecs = []

for m, f in zip(male_words, female_words):
    if m in model and f in model:
        male_vecs.append(model[m])
        female_vecs.append(model[f])
        labels.append((m, f))
    else:
        print(f"⚠️ 缺失词向量: {m} - {f}")

# ✅ 执行 PCA 降维
all_vecs = np.array(male_vecs + female_vecs)
pca = PCA(n_components=2)
proj = pca.fit_transform(all_vecs)

# ✅ 可视化性别方向
plt.figure(figsize=(12, 8))
n = len(labels)

for i in range(n):
    # 绘制 male 和 female 点
    plt.scatter(proj[i, 0], proj[i, 1], color='blue')
    plt.scatter(proj[i+n, 0], proj[i+n, 1], color='red')

    # 画箭头 male → female
    plt.arrow(proj[i, 0], proj[i, 1],
              proj[i+n, 0] - proj[i, 0],
              proj[i+n, 1] - proj[i, 1],
              color='gray', alpha=0.5, head_width=0.1, length_includes_head=True)

    # 标签（可选择是否显示）
    plt.text(proj[i, 0], proj[i, 1], labels[i][0], fontsize=9, color='blue')
    plt.text(proj[i+n, 0], proj[i+n, 1], labels[i][1], fontsize=9, color='red')

# ✅ 图表样式
plt.title('PCA Projection of Gender Word Pairs')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.grid(True)
plt.show()

"""多重验证"""

from google.colab import files
uploaded = files.upload()

# 📦 安装依赖
!pip install pandas openpyxl --quiet # Keep openpyxl here
!pip install numpy==1.19.5 scipy==1.5.4 scikit-learn==0.24.2 --quiet # Specify compatible versions
!pip install gensim umap-learn spacy -U --quiet # Install other packages
!python -m spacy download en_core_web_md --quiet

import pandas as pd
import numpy as np
from gensim.models import KeyedVectors
import gensim.downloader as api
from google.colab import files
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
import umap.umap_ as umap
from sklearn.metrics.pairwise import cosine_similarity
import spacy
from google.colab import drive

# ✅ 加载 spaCy 嵌入模型
nlp = spacy.load("en_core_web_md")

# ✅ 上传文件
excel_file = list(uploaded.keys())[0]

# ✅ 读取文件（包含 male_word 和 female_word 两列）
df = pd.read_excel(excel_file)

# ✅ 构造词向量列表
male_vecs, female_vecs, labels = [], [], []

for idx, row in df.iterrows():
    m, f = str(row['male_word']), str(row['female_word'])
    if m in nlp.vocab and f in nlp.vocab and nlp.vocab[m].has_vector and nlp.vocab[f].has_vector:
        male_vecs.append(nlp.vocab[m].vector)
        female_vecs.append(nlp.vocab[f].vector)
        labels.append((m, f))

print(f"✅ 成功加载 {len(labels)} 对词对用于评估")

# ✅ 计算性别方向
gender_direction = np.mean(female_vecs, axis=0) - np.mean(male_vecs, axis=0)

# ✅ 计算每对词的方向与性别方向的一致性（cosine similarity）
projection_scores = []
for i in range(len(labels)):
    g_vec = female_vecs[i] - male_vecs[i]
    score = cosine_similarity([g_vec], [gender_direction])[0][0]
    projection_scores.append(score)

# ✅ 保存投影分数
score_df = pd.DataFrame(labels, columns=['male_word', 'female_word'])
score_df['cosine_with_gender_direction'] = projection_scores
score_df.to_csv("gender_projection_scores.csv", index=False)
files.download("gender_projection_scores.csv")

# ✅ 可视化分布
plt.figure(figsize=(8, 5))
plt.hist(projection_scores, bins=20, color='skyblue', edgecolor='black')
plt.axvline(np.mean(projection_scores), color='red', linestyle='--', label='Mean')
plt.title('Cosine Similarity with Gender Direction')
plt.xlabel('Cosine Similarity')
plt.ylabel('Count')
plt.grid(True)
plt.legend()
plt.show()

# ✅ 降维可视化函数
def plot_2d_projection(method='pca'):
    vectors = np.array(male_vecs + female_vecs)
    labels_text = [m for m, _ in labels] + [f for _, f in labels]
    colors = ['blue'] * len(male_vecs) + ['red'] * len(female_vecs)

    try:
        if method == 'pca':
            reducer = PCA(n_components=2)
        elif method == 'tsne':
            # 设置自动适应的 perplexity（不超过样本数的 1/3）
            perplexity = min(30, (len(vectors) - 1) // 3)
            reducer = TSNE(n_components=2, perplexity=perplexity, random_state=42)
        elif method == 'umap':
            reducer = umap.UMAP(n_components=2, random_state=42)
        else:
            raise ValueError('Unsupported method')

        proj = reducer.fit_transform(vectors)

        # 绘图
        plt.figure(figsize=(10, 7))
        for i, (x, y) in enumerate(proj):
            plt.scatter(x, y, color=colors[i])
            plt.text(x, y, labels_text[i], fontsize=8, alpha=0.6)
        plt.title(f'{method.upper()} Projection of Gender Word Pairs')
        plt.grid(True)
        plt.show()

    except Exception as e:
        print(f"⚠️ Could not generate {method.upper()} plot: {str(e)}")

# ✅ 三种降维方式可视化
plot_2d_projection('pca')
plot_2d_projection('tsne')
plot_2d_projection('umap')

"""W2V版本

0. 安装依赖
1. 挂载 Google Drive（用于模型缓存）
2. 下载并解压 Word2Vec 模型（若本地不存在）
3. 加载 Word2Vec 模型
"""

!pip install pandas numpy
!pip install gensim openpyxl

import pandas as pd
import numpy as np
from gensim.models import KeyedVectors

import pandas as pd
import numpy as np
from gensim.models import KeyedVectors

from google.colab import drive
drive.mount('/content/drive')

# 自定义路径：模型将缓存到这个位置
model_drive_path = "/content/drive/MyDrive/GoogleNews-vectors-negative300.bin"

import os

if not os.path.exists(model_drive_path):
    print("模型不存在，正在下载...")
    !wget -P /tmp/ https://s3.amazonaws.com/dl4j-distribution/GoogleNews-vectors-negative300.bin.gz
    !gunzip /tmp/GoogleNews-vectors-negative300.bin.gz
    !cp /tmp/GoogleNews-vectors-negative300.bin $model_drive_path
else:
    print("模型已存在，跳过下载。")


from gensim.models import KeyedVectors

model = KeyedVectors.load_word2vec_format(model_drive_path, binary=True)
print("模型加载完成")